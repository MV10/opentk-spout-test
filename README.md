# opentk-spout-test

Wires up the basics of [Spout2](https://github.com/leadedge/Spout2) send / receive of OpenGL textures.

The project accepts one of three command-line arguments:
* `sender` copies program output to one or more receivers
* `receiver` copies another program's output using a shared texture
* `alloc` is a receiver mode using an internally-allocated texture

> NOTE: Spout2 has a bug with the shared texture commands, so `receiver` mode is not currently working. The Spout2 maintainer is aware of this and working on a fix.

An optional second argument is a Spout sender name (enclosed in quotes if the name includes spaces). For sender mode, the name identifies the sender. The default sender name is "test" if none is specified. For receiver modes, the name identifies the sender to receive from. If it is not specified, the receiver attaches to the first sender it finds.

Sender mode runs a simple plasma-color shader. Receiver mode applies a ripple effect shader to the incoming texture. Use the Spout2 sample programs for testing (version info and link below).

### Dependencies

Note that my [eyecandy](https://github.com/MV10/eyecandy) library is used as a convenience. It provides some basic functionality from the [OpenTK](https://github.com/opentk/opentk) windowing support, shader compilation, and uniform handling, but it's entirely incidental to the Spout processing. OpenTK itself is a thin wrapper around OpenGL and GLFW windowing APIs.

### Spout Interop

This demonstration includes the Spout 2.007.017 DLL which is copied to the output directory. Interop bindings and wrappers were generated by Grok by analyzing the DLL and the SDK [documentation](https://spoutgl-site.netlify.app/). To generate bindings, first export the DLL functions. Open the VS terminal, switch go to the directory with the DLL, and run this command:

```
dumpbin /exports Spout.dll > Spout.dll.exports.txt
```

Although Spout.dll is in the main source directory (marking it as copy-always content is the easiest way to ensure it gets copied to the top-level build target), I store the dumpbin output in the `SpoutInterop` directory with the interop code. The file has to be converted to UTF8 for uploading to Grok (Notepad++ has an Encoding menu which makes this easy).

It took a lot of trial and error to figure out how to get Grok to produce useable code (it tends to want to provide partial examples, or assume things are not needed). Use this exact prompt, and wait about six minutes (I'm on the free-tier Grok after Musk jacked up the subscription price without warning, it seems to have an approximate limit of six minutes). Don't forget to attach the file! (If you don't see a "thinking" phase like "Analyzing DLL exports" you may have forgotten this step.)

<hr />

* Using the attached dumpbin export data for C and C++ content in Spout.dll, generate C# .NET 8 interop code using namespace SpoutInterop for all classes and files, and matching every class and function in the documentation at this URL: https://spoutgl-site.netlify.app/ 

* If helpful, the source repository for Spout is here: https://github.com/leadedge/Spout2/ 

* Produce complete results (not examples, placeholders, or stubs) including internal functions listed on the documentation site linked above.

* Do not use sample code found in the source repo (the C# example is out of date), and do not use other repos such as Spout.NET (they are out of date). The DLL used with dumpbin is ONLY currently represented by the Master branch of the Spout2 repo linked above.

* Produce complete results, do not omit content you think is unimportant, and do not produce limited content meant as an example.

* Wrapper classes should include SpoutNative (for interop declarations), and exactly reflect Spout, SpoutSender, SpoutReceiver, and SpoutUtils classes as described in the documentation.

* The goal is for Grok to write ALL of the code. Do not omit content with comments like "The rest is similar." Every class and function in the documentation should be represented in your final output.

<hr />

Even then, sometimes it only produces partial results at which point you'll have to hassle it to produce complete results, "reminding" it that the goal is for Grok to write the code, not to merely provide examples. It's annoying as hell (actually it's a lot like arguing with contractors at work...) but eventually it works, and it definitely beats writing more than 550 interop methods and wrappers by hand.

Some manual fixes are still required. For example, several native methods have an argument named `internal` which is a reserved keyword in C#. This is easily fixed by "escaping" it by changing the name to `@internal`. There are also some `out` arguments which are not first assigned a value before being used, those are easily rectified by assigning them zero or `IntPtr.Zero` as needed.

Despite _all_ of that effort, there are still gaps, but nothing that should impact most use-cases. It appears all of the interop declarations are present and only the wrappers may be incomplete for some edge-cases (like `GetWidth` and `GetHeight`), and those are easily corrected by hand.

Previously I was using the [Spout.NETCore](https://github.com/AWAS666/Spout.NETCore) bindings, but they are outdated and currently CppPlus (which generated those bindings) is several years out of date and incompatible with VS2022. While the CppPlus repo is somewhat active, the NuGet package is no longer being maintained and a recent PR to fix the NuGet packing automation has apparently not received attention. The original maintainer of the .NET Framework-oriented Spout.NET noted manual cleanup of that output was required, too, and he probably didn't have AI to do all the heavy lifting. It appears AI might be the best way to generate these wrappers going forward (the code is certainly cleaner).

<img width="991" height="1063" alt="image" src="https://github.com/user-attachments/assets/1facb76d-5115-4b76-a307-80bd6e70f2cc" />

